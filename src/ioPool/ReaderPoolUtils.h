#pragma once
/*
 * (C) Copyright 2022-2023 UCAR
 *
 * This software is licensed under the terms of the Apache Licence Version 2.0
 * which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
 */
/// \file ReaderUtils.h
/// \brief Utilities for a ioda io reader backend

#include <memory>
#include <string>
#include <vector>

#include "eckit/mpi/Comm.h"

#include "ioda/ioPool/ReaderPoolBase.h"

#include "oops/mpi/mpi.h"
#include "oops/util/DateTime.h"

namespace ioda {

class Distribution;
class Group;

namespace IoPool {

class ReaderPoolBase;

/// Enum type for the different formats of the datetime variable
enum class DateTimeFormat {
    None,
    Offset,
    String,
    Epoch
};

/// @brief Convert epoch string into a DateTime object.
/// @param epochString epoch specification in ISO 8601 format
/// @param epochDtime DateTime object with equivalent value to the epochString
void convertEpochStringToDtime(const std::string & epochString, util::DateTime & epochDtime);

/// @brief Check obs source for required variables
/// @param srcGroup ioda Group object holding obs source data (file or generator)
/// @param commAll mpi communicator group holding all MPI tasks
/// @param sourceName name of the input obs source
/// @param dtimeFormat format of the datetime variable in the obs source
/// @param emptyFile flag when true have a file with zero obs
void checkForRequiredVars(const ioda::Group & srcGroup, const eckit::mpi::Comm & commAll,
                          std::string & sourceName, DateTimeFormat & dtimeFormat,
                          bool & emptyFile);

/// @brief Read date time variable values from obs source
/// @param obsSource ioda Group object holding obs source data (file or generator)
/// @param commAll mpi communicator group holding all MPI tasks
/// @param emptyFile flag when true have a file with zero obs
/// @param dtimeFormat enum value denoting which datetime format exists in the obs source
/// @param dtimeVals vector of int64_t to hold date time values
/// @param dtimeEpoch string value for datetime variable units
void readSourceDtimeVar(const ioda::Group & srcGroup, const eckit::mpi::Comm & commAll,
                        const bool emptyFile, const DateTimeFormat dtimeFormat,
                        std::vector<int64_t> & dtimeVals, std::string & dtimeEpoch);

/// @brief Initialize the location indices
/// @detail If applyLocCheck is false, then sourceLocIndices is initialize to the entire
/// set of locations in the obs source. Otherwise the timing window filter is applied
/// along with the removal of locations with missing lon and lat values.
/// @param obsSource ioda Group object holding obs source data (file or generator)
/// @param commAll mpi communicator group holding all MPI tasks
/// @param emptyFile flag when true have a file with zero obs
/// @param dtimeValues vector of int64_t to hold date time values
/// @param windowStart int64_t timing window start relative to the dtimeValues epoch
/// @param windowEnd int64_t timing window end relative to the dtimeValues epoch
/// @param applyLocCheck boolean flag, true indicates that locations need to be checked
/// @param lonValues vector of float to hold longitude values
/// @param latValues vector of float to hold latitude values
/// @param sourceLocIndices location indices that will be kept on this MPI process
/// @param srcNlocs total number of locations from the obs source
/// @param srcNlocsInsideTimeWindow count of locations that are inside the time window
/// @param srcNlocsOutsideTimeWindow count of locations that are outside the time window
/// @param srcNlocsRejectQc count of locations that were rejected by the QC checks
/// @param globalNlocs total number of locations kept (before MPI distribution)
void initSourceIndices(const ioda::Group & srcGroup, const eckit::mpi::Comm & commAll,
        const bool emptyFile, const std::vector<int64_t> & dtimeValues,
        const util::TimeWindow & timeWindow,
        const bool applyLocCheck,
        std::vector<float> & lonValues, std::vector<float> & latValues,
        std::vector<std::size_t> & sourceLocIndices,
        std::size_t & srcNlocs, std::size_t & srcNlocsInsideTimeWindow,
        std::size_t & srcNlocsOutsideTimeWindow, std::size_t & srcNlocsRejectQc,
        std::size_t & globalNlocs);

/// @brief build a list of keys based on the obs grouping variables
/// @param srcGroup ioda Group object holding obs source data (file or generator)
/// @param dtimeValues vector of int64_t to hold date time values
/// @param lonValues vector of float to hold longitude values
/// @param latValues vector of float to hold latitude values
/// @param sourceLocIndices index list generated by initSourceIndices
/// @param obsGroupVarList list of grouping vars from YAML spec
/// @param groupingKeys keys (strings) that hold tuple values based on the obs grouping vars
void buildObsGroupingKeys(const ioda::Group & srcGroup,
                          const std::vector<int64_t> & dtimeValues,
                          const std::vector<float> & lonValues,
                          const std::vector<float> & latValues,
                          const std::vector<std::string> & obsGroupVarList,
                          const std::vector<std::size_t> & sourceLocIndices,
                          std::vector<std::string> & groupingKeys);

/// @brief Assign record numbers based on the obs grouping (if specified)
/// @detail If obs grouping is specified, then form the groups and generate record numbers
/// accordingly. That is, one unique record number per group. If obs grouping is not specified,
/// simply generate sequential record numbers starting with zero (ie, one-to-one mapping
/// with the location indices). Do either of these algorithms with awareness of any
/// locations that got filtered out during the QC checks (eg., outside the timing window).
/// @param srcGroup ioda Group object holding obs source data (file or generator)
/// @param commAll mpi communicator group holding all MPI tasks
/// @param emptyFile flag when true have a file with zero obs
/// @param dtimeValues vector of int64_t to hold date time values
/// @param lonValues vector of float to hold longitude values
/// @param latValues vector of float to hold latitude values
/// @param sourceLocIndices index list generated by initSourceIndices
/// @param obsGroupVarList list of groupgin vars from YAML spec
/// "obs space.obsdatain.obsgrouping.group variables"
/// @param sourceRecNums assigned record number for each entry in sourceLocIndices
void assignRecordNumbers(const ioda::Group & srcGroup, const eckit::mpi::Comm & commAll,
                         const bool emptyFile, const std::vector<int64_t> & dtimeValues,
                         const std::vector<float> & lonValues,
                         const std::vector<float> & latValues,
                         const std::vector<std::size_t> & sourceLocIndices,
                         const std::vector<std::string> & obsGroupVarList,
                         std::vector<std::size_t> & sourceRecNums);

/// @brief Determine which locations and records belong to this MPI process
/// @param dist MPI distribution object
/// @param emptyFile flag when true have a file with zero obs
/// @param lonValues vector of float to hold longitude values
/// @param latValues vector of float to hold latitude values
/// @param sourceLocIndices index list generated by initSourceIndices
/// @param sourceRecNums record numbers generated by assignRecordNumbers
/// @param localLocIndices list of indices to keep on this MPI process
/// @param localRecNums list of record numbers to keep on this MPI process
/// @param localNlocs number of locations kept on this MPI process
/// @param localNrecs number of unique record numbers kept on this MPI process
void applyMpiDistribution(const std::shared_ptr<Distribution> & dist, const bool emptyFile,
                          const std::vector<float> & lonValues,
                          const std::vector<float> & latValues,
                          const std::vector<std::size_t> & sourceLocIndices,
                          const std::vector<std::size_t> & sourceRecNums,
                          std::vector<std::size_t> & localLocIndices,
                          std::vector<std::size_t> & localRecNums,
                          std::size_t & localNlocs, std::size_t & localNrecs);

/// @brief Determine the location indices and record numbers of locations to keep
/// @param srcGroup ioda Group object holding obs source data (file or generator)
/// @param commAll mpi communicator group holding all MPI tasks
/// @param emptyFile flag when true have a file with zero obs
/// @param dtimeValues vector of int64_t to hold date time values
/// @param windowStart int64_t timing window start relative to the dtimeValues epoch
/// @param windowEnd int64_t timing window end relative to the dtimeValues epoch
/// @param applyLocCheck boolean flag, true indicates that locations need to be checked
/// @param obsGroupVarList list of variables to be used for the obs grouping feature
/// @param lonValues vector of float to hold longitude values
/// @param latValues vector of float to hold latitude values
/// @param srcNlocs total number of locations from the obs source
/// @param srcNlocsInsideTimeWindow count of locations that are inside the time window
/// @param srcNlocsOutsideTimeWindow count of locations that are outside the time window
/// @param srcNlocsRejectQc count of locations that were rejected by the QC checks
/// @param localLocIndices location indices that will be kept on this MPI process
/// @param localRecNums correspoding record numbers for entries of localeLocIndices
/// @param globalNlocs total number of locations kept (before MPI distribution)
/// @param localNlocs number of locations kept on this MPI process
/// @param localNrecs number of records kept on this MPI process
void setIndexAndRecordNums(const ioda::Group & srcGroup, const eckit::mpi::Comm & commAll,
        const bool emptyFile, const std::shared_ptr<ioda::Distribution> & distribution,
        const std::vector<int64_t> & dtimeValues,
        const util::TimeWindow & timeWindow,
        const bool applyLocCheck,
        const std::vector<std::string> & obsGroupVarList,
        std::vector<float> & lonValues, std::vector<float> & latValues,
        std::size_t & srcNlocs, std::size_t & srcNlocsInsideTimeWindow,
        std::size_t & srcNlocsOutsideTimeWindow, std::size_t & srcNlocsRejectQc,
        std::vector<std::size_t> & localLocIndices,
        std::vector<std::size_t> & localRecNums,
        std::size_t & globalNlocs, std::size_t & localNlocs, std::size_t & localNrecs);

/// @brief gather local index values on rank 0
/// @param ioPool ReaderPoolBase object
/// @param localLocIndices list of indices to keep on this MPI process
/// @param rankAssignment structure that indicates which ranks are associated with each other
/// @param distributionMap map describing which source locations go to each associated
/// non pool member
void setDistributionMap(const ReaderPoolBase & ioPool,
                        const std::vector<std::size_t> & localLocIndices,
                        const std::vector<std::pair<int, int>> & rankAssignment,
                        ReaderDistributionMap & distributionMap);

/// @brief set up the reader working directory
/// @param ioPool reader pool object
/// @param workDirBase specification for the work directory ("work directory" config value)
/// @param fileName representative file name for the source of the obs data (generator or file)
/// @param workDir full path to the work directory
void readerCreateWorkDirectory(const ReaderPoolBase & ioPool, const std::string & workDirBase,
                               const std::string & fileName, std::string & workDir);

/// @brief create the pre-processed input files
/// @detail This routine will create a file for each member of the io pool containing
/// a copy of the original input file data, but containing only the locations that go
/// to the non-pool tasks that the pool task is distributing to. The locations are also
/// rearranged so that they appear in the file in contiguous blocks for each destination task.
/// This routine carries over dateTime (with dateTime epoch), lat and lon values since these
/// have already been read in and processed by the initialization steps before this function
/// is called. This is done to avoid repeating these steps.
/// @param ioPool reader pool object
/// @param srcGroup ioda Group object associated with source (eg, input file)
/// @param dtimeValues date time values in the epoch format
/// @param dtimeEpoch date time epoch string
/// @param lonValues longitude values
/// @param latValues latitude values
void readerCreateFileSet(const ReaderPoolBase & ioPool, const Group & srcGroup,
                         const std::vector<int64_t> & dtimeValues,
                         const std::string & dtimeEpoch,
                         const std::vector<float> & lonValues,
                         const std::vector<float> & latValues);

/// @brief copy the groups and attributes from fileGroup to memGroup
/// @param ioPool ioda ReaderPoolBase object
/// @param fileGroup is the source file group
/// @param emptyFile true if input file is empty (ie, source nlocs is zero)
/// @param memGroup is the destination memory group
/// @param groupStructureYaml string holding a YAML description of the file group structure
void readerCopyGroupStructure(const ReaderPoolBase & ioPool,
                              const ioda::Group & fileGroup, const bool emptyFile,
                              ioda::Group & memGroup, std::string & groupStructureYaml);

/// @brief adjust the distribution map according to the new input file
/// @param ioPool ioda ReaderPoolBase object
/// @param fileGroup is the source file group
/// @param rankAssignment structure that indicates which ranks are associated with each other
/// @param distributionMap io pool distribution map
void readerAdjustDistributionMap(const ReaderPoolBase & ioPool,
                                 const ioda::Group & fileGroup,
                                 const std::vector<std::pair<int, int>> & rankAssignment,
                                 ReaderDistributionMap & distributionMap);

/// @brief transfer the variable data from fileGroup to memGroup
/// @param ioPool ioda ReaderPoolBase object
/// @param fileGroup is the source file group
/// @param memGroup is the destination memory group
/// @param groupStructureYaml string holding a YAML description of the file group structure
void readerTransferVarData(const ReaderPoolBase & ioPool,
                           const ioda::Group & fileGroup, ioda::Group & memGroup,
                           std::string & groupStructureYaml);

//------------------------------------------------------------------------------------
// Old reader functions
//------------------------------------------------------------------------------------

/// @brief Transfer group contents from a file group to a memory group using an io pool
/// @param ioPool ioda ReaderPoolBase object
/// @param fileGroup is the source file group
/// @param memGroup is the destination memory group
/// @param dtimeFormat enum value denoting which datetime format exists in the obs source
/// @param dtimeVals vector of int64_t to hold date time values
/// @param dtimeEpoch string value for datetime variable units
/// @param lonValues vector of float to hold longitude values
/// @param latValues vector of float to hold latitude values
/// @param isParallelIo true if reading the input file in parallel IO mode
/// @param emptyFile true if reading from an empty file
void ioReadGroup(const ReaderPoolBase & ioPool, const ioda::Group& fileGroup,
                 ioda::Group& memGroup, const DateTimeFormat dtimeFormat,
                 std::vector<int64_t> & dtimeVals, const std::string & dtimeEpoch,
                 std::vector<float> & lonValues, std::vector<float> & latValues,
                 const bool isParallelIo, const bool emptyFile);

}  // namespace IoPool
}  // namespace ioda
