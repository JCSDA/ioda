#pragma once
/*
 * (C) Copyright 2022-2023 UCAR
 *
 * This software is licensed under the terms of the Apache Licence Version 2.0
 * which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
 */
/// \file ReaderUtils.h
/// \brief Utilities for a ioda io reader backend

#include <memory>
#include <string>
#include <vector>

#include "eckit/mpi/Comm.h"

#include "ioda/ioPool/ReaderPoolBase.h"

#include "oops/mpi/mpi.h"
#include "oops/util/DateTime.h"
#include "oops/util/TimeWindow.h"

namespace ioda {

class Distribution;
class Group;

namespace IoPool {

class ReaderPoolBase;

/// Enum type for the different formats of the datetime variable
enum class DateTimeFormat {
    None,
    Offset,
    String,
    Epoch
};

/// @brief return the name of the file prep group
std::string filePrepGroupName();

/// @brief Determine which locations and records belong to this MPI process
/// @param dist MPI distribution object
/// @param emptyFile flag when true have a file with zero obs
/// @param lonValues vector of float to hold longitude values
/// @param latValues vector of float to hold latitude values
/// @param sourceLocIndices index list generated by initSourceIndices
/// @param sourceRecNums record numbers generated by assignRecordNumbers
/// @param localLocIndices list of indices to keep on this MPI process
/// @param localRecNums list of record numbers to keep on this MPI process
/// @param localNlocs number of locations kept on this MPI process
/// @param localNrecs number of unique record numbers kept on this MPI process
void applyMpiDistribution(const std::shared_ptr<ioda::Distribution> & dist,
                          const bool emptyFile, const std::vector<float> & lonValues,
                          const std::vector<float> & latValues,
                          const std::vector<std::size_t> & sourceLocIndices,
                          const std::vector<std::size_t> & sourceRecNums,
                          std::vector<std::size_t> & localLocIndices,
                          std::vector<std::size_t> & localRecNums,
                          std::size_t & localNlocs, std::size_t & localNrecs);

/// @brief Emulate the MPI distribution
/// @details This funcion is intended to be used by the standalone application that builds
/// the input file set. The standalone app is to be run on a single process so it needs
/// a way to emulate the target mpi configuration (ie, how many total MPI tasks and how
/// many io pool member tasks). Initially, this will only handle round robin distribution.
/// @param distName name of distribution being emulated
/// @param emptyFile flag when true have a file with zero obs
/// @param targetCommSize targeted number of ranks in "all" communicator group
/// @param targetPoolSize targeted number of ranks in "pool" communicator group
/// @param rankGrouping map showing how the ranks are grouped together in the target io pool
/// @param sourceLocIndices index list generated by initSourceIndices
/// @param sourceRecNums record numbers generated by assignRecordNumbers
/// @param assocAllRanks shows association between a given rank and the io pool it belongs to
/// @param ioPoolRanks shows which ranks belong to the io pool, as well as their pool rank
/// @param locIndicesAllRanks contains distributed locations for all ranks
/// @param locIndicesStarts contains the starting points for each rank in locIndicesAllRanks
/// @param locIndicesCounts contains the count of indices for each rank in locIndicesAllRanks
/// @param recNumsAllRanks same as locIndicesAllRanks except for local record numbers
void emulateMpiDistribution(const std::string & distName, const bool emptyFile,
                            const int targetCommSize, const int targetPoolSize,
                            const IoPoolGroupMap & rankGrouping,
                            const std::vector<std::size_t> & sourceLocIndices,
                            const std::vector<std::size_t> & sourceRecNums,
                            std::vector<int> & assocAllRanks,
                            std::vector<int> & ioPoolRanks,
                            std::vector<std::size_t> & locIndicesAllRanks,
                            std::vector<int> & locIndicesStarts,
                            std::vector<int> & locIndicesCounts,
                            std::vector<std::size_t> & recNumsAllRanks);

/// @brief extract global information from the input source (file or generator)
/// @param comm MPI communicator group
/// @param srcGroup ioda Group object holding obs source data (file or generator)
/// @param readerSource name of source data (typically path to input file)
/// @param timeWindow DA time window
/// @param applyLocCheck true means to apply the location quality checks
/// @param obsGroupVarList list of variables for obs grouping feature
/// @param dtimeValues vector of int64_t to hold date time values
/// @param lonValues vector of longitude values
/// @param latValues vector of latitude values
/// @param sourceLocIndices vector of location indices selected from input file
/// @param sourceRecNums vector of record numbers corresponding to sourceLocIndices
/// @param emptyFile true means the input file has zero locations
/// @param dtimeFormat denotes the date time format in the input file
/// @param dtimeEpoch reference date time value
/// @param globalNlocs total number of locations distributed across all MPI processes
/// @param sourceNlocs total number of locations in the input source file
/// @param sourceNlocsInsideTimeWindow number of locations inside the DA time window
/// @param sourceNlocsOutsideTimeWindow number of locations outside the DA time window
/// @param sourceNlocsRejectQC number of locations rejected by location quality check
void extractGlobalInfoFromSource(const eckit::mpi::Comm & comm,
    const ioda::Group & srcGroup, const std::string & readerSource,
    const util::TimeWindow & timeWindow, const bool applyLocCheck,
    const std::vector<std::string> & obsGroupVarList, std::vector<int64_t> & dtimeValues,
    std::vector<float> & lonValues, std::vector<float> & latValues,
    std::vector<std::size_t> & sourceLocIndices, std::vector<std::size_t> & sourceRecNums,
    bool & emptyFile, DateTimeFormat & dtimeFormat, std::string & dtimeEpoch,
    std::size_t & globalNlocs, std::size_t & sourceNlocs,
    std::size_t & sourceNlocsInsideTimeWindow, std::size_t & sourceNlocsOutsideTimeWindow,
    std::size_t & sourceNlocsRejectQC);

/// @brief gather local index values on rank 0
/// @param ioPool ReaderPoolBase object
/// @param localLocIndices list of indices to keep on this MPI process
/// @param rankAssignment structure that indicates which ranks are associated with each other
/// @param distributionMap map describing which source locations go to each associated
/// non pool member
void setDistributionMap(const ReaderPoolBase & ioPool,
                        const std::vector<std::size_t> & localLocIndices,
                        const std::vector<std::pair<int, int>> & rankAssignment,
                        ReaderDistributionMap & distributionMap);

/// @brief gather rank information related to the io pool organization
/// @param ioPool reader pool object
/// @param assocAllRanks for each rank in commAll shows associated io pool member rank
/// @param ioPoolRanks for each rank in commAll shows its io pool rank (-1 denotes non-pool)
/// @param assocFileNames for each rank in commAll shows its associated input file name
void readerGatherAssociatedRanks(const ReaderPoolBase & ioPool,
                                 std::vector<int> & assocAllRanks,
                                 std::vector<int> & ioPoolRanks,
                                 std::vector<std::string> & assocFileNames);

/// @brief gather rank location distribution information
/// @param ioPool reader pool object
/// @param locIndicesAllRanks rearranged order of locations
/// @param locIndicesStarts start values for the block of locations belonging to each rank
/// @param locIndicesCounts count values for the block of locations belonging to each rank
/// @param recNumsAllRanks rearranged order of record nums (same ordering as locIndicesAllRanks)
void readerGatherLocationInfo(const ReaderPoolBase & ioPool,
                              std::vector<std::size_t> & locIndicesAllRanks,
                              std::vector<int> & locIndicesStarts,
                              std::vector<int> & locIndicesCounts,
                              std::vector<std::size_t> & recNumsAllRanks);

/// @brief build the pre-processed input files after gathering data on rank 0
/// @detail This routine will create a file for each member of the io pool containing
/// a copy of the original input file data, but containing only the locations that go
/// to the non-pool tasks that the pool task is distributing to. The locations are also
/// rearranged so that they appear in the file in contiguous blocks for each destination task.
/// This routine carries over dateTime (with dateTime epoch), lat and lon values since these
/// have already been read in and processed by the initialization steps before this function
/// is called. This is done to avoid repeating these steps.
/// @param ioPool reader pool object
/// @param targetCommAllSize targeted size of the commAll communicator group
/// @param targetCommPoolSize targeted size of the commPool communicator group
/// @param srcGroup ioda Group object associated with source (eg, input file)
/// @param assocAllRanks for each rank in commAll shows associated io pool member rank
/// @param ioPoolRanks for each rank in commAll shows its io pool rank (-1 denotes non-pool)
/// @param assocFileNames for each rank in commAll shows its associated input file name
/// @param locIndicesAllRanks rearranged order of locations
/// @param locIndicesStarts start values for the block of locations belonging to each rank
/// @param locIndicesCounts count values for the block of locations belonging to each rank
/// @param recNumsAllRanks rearranged order of record nums (same ordering as locIndicesAllRanks)
/// @param dtimeValues date time values in the epoch format
/// @param dtimeEpoch date time epoch string
/// @param lonValues longitude values
/// @param latValues latitude values
void readerBuildInputFiles(const ReaderPoolBase & ioPool,
                           const int targetCommAllSize,
                           const int targetCommPoolSize,
                           const Group & srcGroup,
                           const std::vector<int> & assocAllRanks,
                           const std::vector<int> & ioPoolRanks,
                           const std::vector<std::string> & assocFileNames,
                           const std::vector<std::size_t> & locIndicesAllRanks,
                           const std::vector<int> & locIndicesStarts,
                           const std::vector<int> & locIndicesCounts,
                           const std::vector<std::size_t> & recNumsAllRanks,
                           const std::vector<int64_t> & dtimeValues,
                           const std::string & dtimeEpoch,
                           const std::vector<float> & lonValues,
                           const std::vector<float> & latValues);

/// @brief copy the groups and attributes from fileGroup to memGroup
/// @param ioPool ioda ReaderPoolBase object
/// @param fileGroup is the source file group
/// @param emptyFile true if input file is empty (ie, source nlocs is zero)
/// @param memGroup is the destination memory group
/// @param groupStructureYaml string holding a YAML description of the file group structure
void readerCopyGroupStructure(const ReaderPoolBase & ioPool,
                              const ioda::Group & fileGroup, const bool emptyFile,
                              ioda::Group & memGroup, std::string & groupStructureYaml);

/// @brief transfer the variable data from fileGroup to memGroup
/// @param ioPool ioda ReaderPoolBase object
/// @param fileGroup is the source file group
/// @param memGroup is the destination memory group
/// @param groupStructureYaml string holding a YAML description of the file group structure
void readerTransferVarData(const ReaderPoolBase & ioPool,
                           const ioda::Group & fileGroup, ioda::Group & memGroup,
                           std::string & groupStructureYaml);

//------------------------------------------------------------------------------------
// Old reader functions
//------------------------------------------------------------------------------------

/// @brief Transfer group contents from a file group to a memory group using an io pool
/// @param ioPool ioda ReaderPoolBase object
/// @param fileGroup is the source file group
/// @param memGroup is the destination memory group
/// @param dtimeFormat enum value denoting which datetime format exists in the obs source
/// @param dtimeVals vector of int64_t to hold date time values
/// @param dtimeEpoch string value for datetime variable units
/// @param lonValues vector of float to hold longitude values
/// @param latValues vector of float to hold latitude values
/// @param isParallelIo true if reading the input file in parallel IO mode
/// @param emptyFile true if reading from an empty file
void ioReadGroup(const ReaderPoolBase & ioPool, const ioda::Group& fileGroup,
                 ioda::Group& memGroup, const DateTimeFormat dtimeFormat,
                 std::vector<int64_t> & dtimeVals, const std::string & dtimeEpoch,
                 std::vector<float> & lonValues, std::vector<float> & latValues,
                 const bool isParallelIo, const bool emptyFile);

}  // namespace IoPool
}  // namespace ioda
